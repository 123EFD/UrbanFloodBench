{"cells":[{"source":"<a href=\"https://www.kaggle.com/code/chinshier/urbanfloodbnech-gnn-model?scriptVersionId=296582683\" target=\"_blank\"><img align=\"left\" alt=\"Kaggle\" title=\"Open in Kaggle\" src=\"https://kaggle.com/static/images/open-in-kaggle.svg\"></a>","metadata":{},"cell_type":"markdown"},{"cell_type":"code","execution_count":1,"id":"ac78252d","metadata":{"execution":{"iopub.execute_input":"2026-02-08T17:27:45.768073Z","iopub.status.busy":"2026-02-08T17:27:45.767544Z","iopub.status.idle":"2026-02-08T17:28:05.029526Z","shell.execute_reply":"2026-02-08T17:28:05.028093Z"},"papermill":{"duration":19.270787,"end_time":"2026-02-08T17:28:05.032304","exception":false,"start_time":"2026-02-08T17:27:45.761517","status":"completed"},"tags":[]},"outputs":[{"name":"stdout","output_type":"stream","text":["PyTorch Version: 2.8.0+cu126\n","CUDA Version: 12.6\n","\u001b[2K     \u001b[90m‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\u001b[0m \u001b[32m63.7/63.7 kB\u001b[0m \u001b[31m1.5 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\r\n","\u001b[2K   \u001b[90m‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\u001b[0m \u001b[32m1.3/1.3 MB\u001b[0m \u001b[31m18.9 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\r\n","\u001b[?25hInstalling dependencies (Scatter, Sparse)... this may take a minute.\n","\u001b[2K     \u001b[90m‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\u001b[0m \u001b[32m10.9/10.9 MB\u001b[0m \u001b[31m80.3 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\r\n","\u001b[2K     \u001b[90m‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\u001b[0m \u001b[32m5.2/5.2 MB\u001b[0m \u001b[31m77.7 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\r\n","\u001b[?25h‚úÖ PyTorch Geometric Installed! You can now run the Graph Construction code.\n"]}],"source":["# --- INSTALLATION BLOCK ---\n","import torch\n","\n","def install_pyg():\n","    print(f\"PyTorch Version: {torch.__version__}\")\n","    print(f\"CUDA Version: {torch.version.cuda}\")\n","    \n","    # 1. Install Core PyG\n","    !pip install -q torch-geometric\n","    \n","    # 2. Install Optional Dependencies (Scatter & Sparse are needed for GNN layers)\n","    # We use a helper to find the right wheel for the installed Torch/CUDA version\n","    try:\n","        import torch_scatter, torch_sparse\n","    except ImportError:\n","        print(\"Installing dependencies (Scatter, Sparse)... this may take a minute.\")\n","        # General install command that looks for binary wheels\n","        !pip install -q torch-scatter torch-sparse -f https://data.pyg.org/whl/torch-{torch.__version__}.html\n","\n","install_pyg()\n","print(\"‚úÖ PyTorch Geometric Installed! You can now run the Graph Construction code.\")"]},{"cell_type":"code","execution_count":2,"id":"6631fe55","metadata":{"_cell_guid":"b1076dfc-b9ad-4769-8c92-a6c4dae69d19","_uuid":"8f2839f25d086af736a60e9eeb907d3b93b6e0e5","execution":{"iopub.execute_input":"2026-02-08T17:28:05.044114Z","iopub.status.busy":"2026-02-08T17:28:05.043345Z","iopub.status.idle":"2026-02-08T17:28:06.496184Z","shell.execute_reply":"2026-02-08T17:28:06.494498Z"},"papermill":{"duration":1.461693,"end_time":"2026-02-08T17:28:06.498724","exception":false,"start_time":"2026-02-08T17:28:05.037031","status":"completed"},"tags":[]},"outputs":[{"name":"stdout","output_type":"stream","text":["/kaggle/input/submission/submission_gnn.csv\n","/kaggle/input/submission/submission.csv\n","/kaggle/input/urbanfloodbench/test_2d_edges_dynamic_all.csv\n","/kaggle/input/urbanfloodbench/test_2d_edges_static.csv\n","/kaggle/input/urbanfloodbench/timesteps.csv\n","/kaggle/input/urbanfloodbench/sample_submission.csv\n","/kaggle/input/urbanfloodbench/test_2d_nodes_dynamic_all.csv\n","/kaggle/input/urbanfloodbench/test_1d_edges_dynamic_all.csv\n","/kaggle/input/urbanfloodbench/1d2d_connections.csv\n","/kaggle/input/urbanfloodbench/1d_nodes_static.csv\n","/kaggle/input/urbanfloodbench/2d_nodes_dynamic_all.csv\n","/kaggle/input/urbanfloodbench/2d_edges_dynamic_all.csv\n","/kaggle/input/urbanfloodbench/test_timesteps.csv\n","/kaggle/input/urbanfloodbench/1d_edge_index.csv\n","/kaggle/input/urbanfloodbench/2d_edges_static.csv\n","/kaggle/input/urbanfloodbench/test_2d_edge_index.csv\n","/kaggle/input/urbanfloodbench/1d_edges_static.csv\n","/kaggle/input/urbanfloodbench/test_1d_edges_static.csv\n","/kaggle/input/urbanfloodbench/1d_edges_dynamic_all.csv\n","/kaggle/input/urbanfloodbench/sample_submission.parquet\n","/kaggle/input/urbanfloodbench/submission.csv\n","/kaggle/input/urbanfloodbench/2d_edge_index.csv\n","/kaggle/input/urbanfloodbench/2d_nodes_static.csv\n","/kaggle/input/urbanfloodbench/test_2d_nodes_static.csv\n","/kaggle/input/urbanfloodbench/test_1d_nodes_static.csv\n","/kaggle/input/urbanfloodbench/test_1d2d_connections.csv\n","/kaggle/input/urbanfloodbench/1d_nodes_dynamic_all.csv\n","/kaggle/input/urbanfloodbench/test_1d_nodes_dynamic_all.csv\n","/kaggle/input/urbanfloodbench/my_raw_predictions.csv\n","/kaggle/input/urbanfloodbench/test_1d_edge_index.csv\n"]}],"source":["# This Python 3 environment comes with many helpful analytics libraries installed\n","# It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python\n","# For example, here's several helpful packages to load\n","\n","import numpy as np # linear algebra\n","import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)\n","\n","# Input data files are available in the read-only \"../input/\" directory\n","# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n","\n","import os\n","for dirname, _, filenames in os.walk('/kaggle/input'):\n","    for filename in filenames:\n","        print(os.path.join(dirname, filename))\n","\n","# You can write up to 20GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using \"Save & Run All\" \n","# You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session"]},{"cell_type":"code","execution_count":3,"id":"9daa0121","metadata":{"execution":{"iopub.execute_input":"2026-02-08T17:28:06.511335Z","iopub.status.busy":"2026-02-08T17:28:06.510788Z","iopub.status.idle":"2026-02-08T17:28:07.181339Z","shell.execute_reply":"2026-02-08T17:28:07.180126Z"},"papermill":{"duration":0.679585,"end_time":"2026-02-08T17:28:07.183758","exception":false,"start_time":"2026-02-08T17:28:06.504173","status":"completed"},"tags":[]},"outputs":[{"name":"stdout","output_type":"stream","text":["Loading training data for statistics...\n","‚úÖ Calculated Constants:\n","Sigma 1D: 16.800592891244573\n","Sigma 2D: 14.362006861860646\n"]}],"source":["import pandas as pd\n","import numpy as np\n","\n","# Load Training Data\n","print(\"Loading training data for statistics...\")\n","train_1d = pd.read_csv('/kaggle/input/urbanfloodbench/1d_nodes_dynamic_all.csv')\n","train_2d = pd.read_csv('/kaggle/input/urbanfloodbench/2d_nodes_dynamic_all.csv')\n","\n","# Calculate Sigma (Standard Deviation)\n","sigma_1d = train_1d['water_level'].std()\n","sigma_2d = train_2d['water_level'].std()\n","\n","print(f\"‚úÖ Calculated Constants:\")\n","print(f\"Sigma 1D: {sigma_1d}\")\n","print(f\"Sigma 2D: {sigma_2d}\")"]},{"cell_type":"code","execution_count":4,"id":"eaa996b1","metadata":{"execution":{"iopub.execute_input":"2026-02-08T17:28:07.19531Z","iopub.status.busy":"2026-02-08T17:28:07.194502Z","iopub.status.idle":"2026-02-08T17:28:07.203791Z","shell.execute_reply":"2026-02-08T17:28:07.202488Z"},"papermill":{"duration":0.017196,"end_time":"2026-02-08T17:28:07.206016","exception":false,"start_time":"2026-02-08T17:28:07.18882","status":"completed"},"tags":[]},"outputs":[],"source":["import torch\n","import torch.nn as nn\n","\n","class StandardizedRMSELoss(nn.Module):\n","    def __init__(self, sigma_1d, sigma_2d):\n","        super().__init__()\n","        # Register sigmas as buffers so they move to GPU automatically with the model\n","        self.register_buffer('sigma_1d', torch.tensor(sigma_1d))\n","        self.register_buffer('sigma_2d', torch.tensor(sigma_2d))\n","        self.mse = nn.MSELoss()\n","\n","    def forward(self, pred, target, node_type_mask):\n","        \"\"\"\n","        pred: Predicted values [Batch, Nodes]\n","        target: Actual values [Batch, Nodes]\n","        node_type_mask: Boolean tensor where True = 1D Node, False = 2D Node\n","        \"\"\"\n","        # Split predictions by node type\n","        pred_1d = pred[node_type_mask]\n","        target_1d = target[node_type_mask]\n","        \n","        pred_2d = pred[~node_type_mask]\n","        target_2d = target[~node_type_mask]\n","        \n","        # Calculate RMSE for each\n","        rmse_1d = torch.sqrt(self.mse(pred_1d, target_1d))\n","        rmse_2d = torch.sqrt(self.mse(pred_2d, target_2d))\n","        \n","        # Standardize\n","        std_rmse_1d = rmse_1d / self.sigma_1d\n","        std_rmse_2d = rmse_2d / self.sigma_2d\n","        \n","        # Return average (Competition Metric)\n","        return (std_rmse_1d + std_rmse_2d) / 2"]},{"cell_type":"code","execution_count":5,"id":"e6b54eba","metadata":{"execution":{"iopub.execute_input":"2026-02-08T17:28:07.21692Z","iopub.status.busy":"2026-02-08T17:28:07.216409Z","iopub.status.idle":"2026-02-08T17:28:07.566191Z","shell.execute_reply":"2026-02-08T17:28:07.565232Z"},"papermill":{"duration":0.357949,"end_time":"2026-02-08T17:28:07.56822","exception":false,"start_time":"2026-02-08T17:28:07.210271","status":"completed"},"tags":[]},"outputs":[{"name":"stdout","output_type":"stream","text":["Columns in 1D Edge Index:\n","['edge_idx', 'from_node', 'to_node']\n"]},{"data":{"text/html":["<div>\n","<style scoped>\n","    .dataframe tbody tr th:only-of-type {\n","        vertical-align: middle;\n","    }\n","\n","    .dataframe tbody tr th {\n","        vertical-align: top;\n","    }\n","\n","    .dataframe thead th {\n","        text-align: right;\n","    }\n","</style>\n","<table border=\"1\" class=\"dataframe\">\n","  <thead>\n","    <tr style=\"text-align: right;\">\n","      <th></th>\n","      <th>edge_idx</th>\n","      <th>from_node</th>\n","      <th>to_node</th>\n","    </tr>\n","  </thead>\n","  <tbody>\n","    <tr>\n","      <th>0</th>\n","      <td>0</td>\n","      <td>0</td>\n","      <td>16</td>\n","    </tr>\n","    <tr>\n","      <th>1</th>\n","      <td>1</td>\n","      <td>13</td>\n","      <td>12</td>\n","    </tr>\n","    <tr>\n","      <th>2</th>\n","      <td>2</td>\n","      <td>3</td>\n","      <td>13</td>\n","    </tr>\n","    <tr>\n","      <th>3</th>\n","      <td>3</td>\n","      <td>4</td>\n","      <td>3</td>\n","    </tr>\n","    <tr>\n","      <th>4</th>\n","      <td>4</td>\n","      <td>14</td>\n","      <td>4</td>\n","    </tr>\n","  </tbody>\n","</table>\n","</div>"],"text/plain":["   edge_idx  from_node  to_node\n","0         0          0       16\n","1         1         13       12\n","2         2          3       13\n","3         3          4        3\n","4         4         14        4"]},"metadata":{},"output_type":"display_data"},{"name":"stdout","output_type":"stream","text":["Columns in 1D Nodes Dynamic Index:\n","['timestep', 'node_idx', 'water_level', 'inlet_flow']\n"]},{"data":{"text/html":["<div>\n","<style scoped>\n","    .dataframe tbody tr th:only-of-type {\n","        vertical-align: middle;\n","    }\n","\n","    .dataframe tbody tr th {\n","        vertical-align: top;\n","    }\n","\n","    .dataframe thead th {\n","        text-align: right;\n","    }\n","</style>\n","<table border=\"1\" class=\"dataframe\">\n","  <thead>\n","    <tr style=\"text-align: right;\">\n","      <th></th>\n","      <th>timestep</th>\n","      <th>node_idx</th>\n","      <th>water_level</th>\n","      <th>inlet_flow</th>\n","    </tr>\n","  </thead>\n","  <tbody>\n","    <tr>\n","      <th>0</th>\n","      <td>0</td>\n","      <td>0</td>\n","      <td>294.87430</td>\n","      <td>0.000000</td>\n","    </tr>\n","    <tr>\n","      <th>1</th>\n","      <td>0</td>\n","      <td>1</td>\n","      <td>288.22095</td>\n","      <td>0.000000</td>\n","    </tr>\n","    <tr>\n","      <th>2</th>\n","      <td>0</td>\n","      <td>2</td>\n","      <td>311.72510</td>\n","      <td>3.189905</td>\n","    </tr>\n","    <tr>\n","      <th>3</th>\n","      <td>0</td>\n","      <td>3</td>\n","      <td>310.67368</td>\n","      <td>1.829733</td>\n","    </tr>\n","    <tr>\n","      <th>4</th>\n","      <td>0</td>\n","      <td>4</td>\n","      <td>311.72390</td>\n","      <td>0.000000</td>\n","    </tr>\n","  </tbody>\n","</table>\n","</div>"],"text/plain":["   timestep  node_idx  water_level  inlet_flow\n","0         0         0    294.87430    0.000000\n","1         0         1    288.22095    0.000000\n","2         0         2    311.72510    3.189905\n","3         0         3    310.67368    1.829733\n","4         0         4    311.72390    0.000000"]},"metadata":{},"output_type":"display_data"},{"name":"stdout","output_type":"stream","text":["Columns in 1D Nodes Static Index:\n","['node_idx', 'position_x', 'position_y', 'depth', 'invert_elevation', 'surface_elevation', 'base_area']\n"]},{"data":{"text/html":["<div>\n","<style scoped>\n","    .dataframe tbody tr th:only-of-type {\n","        vertical-align: middle;\n","    }\n","\n","    .dataframe tbody tr th {\n","        vertical-align: top;\n","    }\n","\n","    .dataframe thead th {\n","        text-align: right;\n","    }\n","</style>\n","<table border=\"1\" class=\"dataframe\">\n","  <thead>\n","    <tr style=\"text-align: right;\">\n","      <th></th>\n","      <th>node_idx</th>\n","      <th>position_x</th>\n","      <th>position_y</th>\n","      <th>depth</th>\n","      <th>invert_elevation</th>\n","      <th>surface_elevation</th>\n","      <th>base_area</th>\n","    </tr>\n","  </thead>\n","  <tbody>\n","    <tr>\n","      <th>0</th>\n","      <td>0</td>\n","      <td>802465.60</td>\n","      <td>349898.84</td>\n","      <td>8.977997</td>\n","      <td>292.342</td>\n","      <td>301.32</td>\n","      <td>12.56</td>\n","    </tr>\n","    <tr>\n","      <th>1</th>\n","      <td>1</td>\n","      <td>802528.94</td>\n","      <td>349713.56</td>\n","      <td>6.195984</td>\n","      <td>295.164</td>\n","      <td>301.36</td>\n","      <td>12.56</td>\n","    </tr>\n","    <tr>\n","      <th>2</th>\n","      <td>2</td>\n","      <td>802430.44</td>\n","      <td>349608.60</td>\n","      <td>5.480011</td>\n","      <td>297.610</td>\n","      <td>303.09</td>\n","      <td>12.56</td>\n","    </tr>\n","    <tr>\n","      <th>3</th>\n","      <td>3</td>\n","      <td>802420.06</td>\n","      <td>349242.25</td>\n","      <td>4.699982</td>\n","      <td>310.450</td>\n","      <td>315.15</td>\n","      <td>12.56</td>\n","    </tr>\n","    <tr>\n","      <th>4</th>\n","      <td>4</td>\n","      <td>802338.94</td>\n","      <td>349292.66</td>\n","      <td>3.593994</td>\n","      <td>313.376</td>\n","      <td>316.97</td>\n","      <td>12.56</td>\n","    </tr>\n","  </tbody>\n","</table>\n","</div>"],"text/plain":["   node_idx  position_x  position_y     depth  invert_elevation  \\\n","0         0   802465.60   349898.84  8.977997           292.342   \n","1         1   802528.94   349713.56  6.195984           295.164   \n","2         2   802430.44   349608.60  5.480011           297.610   \n","3         3   802420.06   349242.25  4.699982           310.450   \n","4         4   802338.94   349292.66  3.593994           313.376   \n","\n","   surface_elevation  base_area  \n","0             301.32      12.56  \n","1             301.36      12.56  \n","2             303.09      12.56  \n","3             315.15      12.56  \n","4             316.97      12.56  "]},"metadata":{},"output_type":"display_data"},{"name":"stdout","output_type":"stream","text":["Columns in 2D Nodes Static Index:\n","['node_idx', 'position_x', 'position_y', 'area', 'roughness', 'min_elevation', 'elevation', 'aspect', 'curvature', 'flow_accumulation']\n"]},{"data":{"text/html":["<div>\n","<style scoped>\n","    .dataframe tbody tr th:only-of-type {\n","        vertical-align: middle;\n","    }\n","\n","    .dataframe tbody tr th {\n","        vertical-align: top;\n","    }\n","\n","    .dataframe thead th {\n","        text-align: right;\n","    }\n","</style>\n","<table border=\"1\" class=\"dataframe\">\n","  <thead>\n","    <tr style=\"text-align: right;\">\n","      <th></th>\n","      <th>node_idx</th>\n","      <th>position_x</th>\n","      <th>position_y</th>\n","      <th>area</th>\n","      <th>roughness</th>\n","      <th>min_elevation</th>\n","      <th>elevation</th>\n","      <th>aspect</th>\n","      <th>curvature</th>\n","      <th>flow_accumulation</th>\n","    </tr>\n","  </thead>\n","  <tbody>\n","    <tr>\n","      <th>0</th>\n","      <td>0</td>\n","      <td>803051.56</td>\n","      <td>350382.44</td>\n","      <td>825.63544</td>\n","      <td>0.06</td>\n","      <td>329.75012</td>\n","      <td>331.09375</td>\n","      <td>185.94380</td>\n","      <td>0.000082</td>\n","      <td>8.0</td>\n","    </tr>\n","    <tr>\n","      <th>1</th>\n","      <td>1</td>\n","      <td>803076.56</td>\n","      <td>350382.44</td>\n","      <td>616.87900</td>\n","      <td>0.06</td>\n","      <td>329.84910</td>\n","      <td>330.90625</td>\n","      <td>182.54686</td>\n","      <td>0.000036</td>\n","      <td>1.0</td>\n","    </tr>\n","    <tr>\n","      <th>2</th>\n","      <td>2</td>\n","      <td>803101.56</td>\n","      <td>350382.44</td>\n","      <td>611.14510</td>\n","      <td>0.06</td>\n","      <td>329.69390</td>\n","      <td>330.56250</td>\n","      <td>140.86070</td>\n","      <td>0.000004</td>\n","      <td>2.0</td>\n","    </tr>\n","    <tr>\n","      <th>3</th>\n","      <td>3</td>\n","      <td>803126.56</td>\n","      <td>350382.44</td>\n","      <td>605.41113</td>\n","      <td>0.06</td>\n","      <td>329.28427</td>\n","      <td>330.00000</td>\n","      <td>89.00771</td>\n","      <td>0.000022</td>\n","      <td>1.0</td>\n","    </tr>\n","    <tr>\n","      <th>4</th>\n","      <td>4</td>\n","      <td>803151.56</td>\n","      <td>350382.44</td>\n","      <td>599.67720</td>\n","      <td>0.06</td>\n","      <td>328.35257</td>\n","      <td>328.81250</td>\n","      <td>96.00465</td>\n","      <td>0.000061</td>\n","      <td>3.0</td>\n","    </tr>\n","  </tbody>\n","</table>\n","</div>"],"text/plain":["   node_idx  position_x  position_y       area  roughness  min_elevation  \\\n","0         0   803051.56   350382.44  825.63544       0.06      329.75012   \n","1         1   803076.56   350382.44  616.87900       0.06      329.84910   \n","2         2   803101.56   350382.44  611.14510       0.06      329.69390   \n","3         3   803126.56   350382.44  605.41113       0.06      329.28427   \n","4         4   803151.56   350382.44  599.67720       0.06      328.35257   \n","\n","   elevation     aspect  curvature  flow_accumulation  \n","0  331.09375  185.94380   0.000082                8.0  \n","1  330.90625  182.54686   0.000036                1.0  \n","2  330.56250  140.86070   0.000004                2.0  \n","3  330.00000   89.00771   0.000022                1.0  \n","4  328.81250   96.00465   0.000061                3.0  "]},"metadata":{},"output_type":"display_data"},{"name":"stdout","output_type":"stream","text":["Columns in 2D Nodes Dynamic Index:\n","['timestep', 'node_idx', 'rainfall', 'water_level', 'water_volume']\n"]},{"data":{"text/html":["<div>\n","<style scoped>\n","    .dataframe tbody tr th:only-of-type {\n","        vertical-align: middle;\n","    }\n","\n","    .dataframe tbody tr th {\n","        vertical-align: top;\n","    }\n","\n","    .dataframe thead th {\n","        text-align: right;\n","    }\n","</style>\n","<table border=\"1\" class=\"dataframe\">\n","  <thead>\n","    <tr style=\"text-align: right;\">\n","      <th></th>\n","      <th>timestep</th>\n","      <th>node_idx</th>\n","      <th>rainfall</th>\n","      <th>water_level</th>\n","      <th>water_volume</th>\n","    </tr>\n","  </thead>\n","  <tbody>\n","    <tr>\n","      <th>0</th>\n","      <td>0</td>\n","      <td>0</td>\n","      <td>0.143333</td>\n","      <td>329.936523</td>\n","      <td>2.127534</td>\n","    </tr>\n","    <tr>\n","      <th>1</th>\n","      <td>0</td>\n","      <td>1</td>\n","      <td>0.143333</td>\n","      <td>329.985474</td>\n","      <td>0.835427</td>\n","    </tr>\n","    <tr>\n","      <th>2</th>\n","      <td>0</td>\n","      <td>2</td>\n","      <td>0.143333</td>\n","      <td>329.880676</td>\n","      <td>1.661489</td>\n","    </tr>\n","    <tr>\n","      <th>3</th>\n","      <td>0</td>\n","      <td>3</td>\n","      <td>0.143333</td>\n","      <td>329.431030</td>\n","      <td>2.059574</td>\n","    </tr>\n","    <tr>\n","      <th>4</th>\n","      <td>0</td>\n","      <td>4</td>\n","      <td>0.143333</td>\n","      <td>328.498291</td>\n","      <td>1.802438</td>\n","    </tr>\n","  </tbody>\n","</table>\n","</div>"],"text/plain":["   timestep  node_idx  rainfall  water_level  water_volume\n","0         0         0  0.143333   329.936523      2.127534\n","1         0         1  0.143333   329.985474      0.835427\n","2         0         2  0.143333   329.880676      1.661489\n","3         0         3  0.143333   329.431030      2.059574\n","4         0         4  0.143333   328.498291      1.802438"]},"metadata":{},"output_type":"display_data"},{"name":"stdout","output_type":"stream","text":["Columns in 2D1D Connections Index:\n","['connection_idx', 'node_1d', 'node_2d']\n"]},{"data":{"text/html":["<div>\n","<style scoped>\n","    .dataframe tbody tr th:only-of-type {\n","        vertical-align: middle;\n","    }\n","\n","    .dataframe tbody tr th {\n","        vertical-align: top;\n","    }\n","\n","    .dataframe thead th {\n","        text-align: right;\n","    }\n","</style>\n","<table border=\"1\" class=\"dataframe\">\n","  <thead>\n","    <tr style=\"text-align: right;\">\n","      <th></th>\n","      <th>connection_idx</th>\n","      <th>node_1d</th>\n","      <th>node_2d</th>\n","    </tr>\n","  </thead>\n","  <tbody>\n","    <tr>\n","      <th>0</th>\n","      <td>0</td>\n","      <td>0</td>\n","      <td>503</td>\n","    </tr>\n","    <tr>\n","      <th>1</th>\n","      <td>1</td>\n","      <td>13</td>\n","      <td>3669</td>\n","    </tr>\n","    <tr>\n","      <th>2</th>\n","      <td>2</td>\n","      <td>12</td>\n","      <td>3588</td>\n","    </tr>\n","    <tr>\n","      <th>3</th>\n","      <td>3</td>\n","      <td>3</td>\n","      <td>3595</td>\n","    </tr>\n","    <tr>\n","      <th>4</th>\n","      <td>4</td>\n","      <td>4</td>\n","      <td>3600</td>\n","    </tr>\n","  </tbody>\n","</table>\n","</div>"],"text/plain":["   connection_idx  node_1d  node_2d\n","0               0        0      503\n","1               1       13     3669\n","2               2       12     3588\n","3               3        3     3595\n","4               4        4     3600"]},"metadata":{},"output_type":"display_data"}],"source":["import pandas as pd\n","\n","# Load the edge metadata\n","edges_1d = pd.read_csv('/kaggle/input/urbanfloodbench/1d_edge_index.csv')\n","nodes_1d_dynamic = pd.read_csv('/kaggle/input/urbanfloodbench/1d_nodes_dynamic_all.csv')\n","nodes_1d_static = pd.read_csv('/kaggle/input/urbanfloodbench/1d_nodes_static.csv')\n","nodes_2d_dynamic = pd.read_csv('/kaggle/input/urbanfloodbench/2d_nodes_dynamic_all.csv')\n","nodes_2d_static = pd.read_csv('/kaggle/input/urbanfloodbench/2d_nodes_static.csv')\n","conn_1d2d = pd.read_csv('/kaggle/input/urbanfloodbench/1d2d_connections.csv')\n","\n","\n","# View the column names\n","print(\"Columns in 1D Edge Index:\")\n","print(edges_1d.columns.tolist())\n","\n","# View a few rows to see the values\n","display(edges_1d.head())\n","\n","print(\"Columns in 1D Nodes Dynamic Index:\")\n","print(nodes_1d_dynamic.columns.tolist())\n","display(nodes_1d_dynamic.head())\n","\n","print(\"Columns in 1D Nodes Static Index:\")\n","print(nodes_1d_static.columns.tolist())\n","display(nodes_1d_static.head())\n","\n","print(\"Columns in 2D Nodes Static Index:\")\n","print(nodes_2d_static.columns.tolist())\n","display(nodes_2d_static.head())\n","\n","print(\"Columns in 2D Nodes Dynamic Index:\")\n","print(nodes_2d_dynamic.columns.tolist())\n","display(nodes_2d_dynamic.head())\n","\n","print(\"Columns in 2D1D Connections Index:\")\n","print(conn_1d2d.columns.tolist())\n","display(conn_1d2d.head())"]},{"cell_type":"code","execution_count":6,"id":"8f11e227","metadata":{"execution":{"iopub.execute_input":"2026-02-08T17:28:07.582267Z","iopub.status.busy":"2026-02-08T17:28:07.58115Z","iopub.status.idle":"2026-02-08T17:28:07.601669Z","shell.execute_reply":"2026-02-08T17:28:07.600539Z"},"papermill":{"duration":0.029782,"end_time":"2026-02-08T17:28:07.603694","exception":false,"start_time":"2026-02-08T17:28:07.573912","status":"completed"},"tags":[]},"outputs":[{"name":"stdout","output_type":"stream","text":["['node_idx', 'position_x', 'position_y', 'depth', 'invert_elevation', 'surface_elevation', 'base_area']\n","['node_idx', 'position_x', 'position_y', 'area', 'roughness', 'min_elevation', 'elevation', 'aspect', 'curvature', 'flow_accumulation']\n"]}],"source":["import pandas as pd\n","\n","# Load the CSV file\n","static_1d = pd.read_csv('/kaggle/input/urbanfloodbench/1d_nodes_static.csv')\n","static_2d = pd.read_csv('/kaggle/input/urbanfloodbench/2d_nodes_static.csv')\n","\n","# Print the list of columns\n","print(static_1d.columns.tolist())\n","print(static_2d.columns.tolist())"]},{"cell_type":"code","execution_count":7,"id":"2af0271e","metadata":{"execution":{"iopub.execute_input":"2026-02-08T17:28:07.617367Z","iopub.status.busy":"2026-02-08T17:28:07.616965Z","iopub.status.idle":"2026-02-08T17:28:21.819518Z","shell.execute_reply":"2026-02-08T17:28:21.817978Z"},"papermill":{"duration":14.213394,"end_time":"2026-02-08T17:28:21.822614","exception":false,"start_time":"2026-02-08T17:28:07.60922","status":"completed"},"tags":[]},"outputs":[{"name":"stdout","output_type":"stream","text":["üèóÔ∏è Building Enhanced Unified Graph Object...\n","‚úÖ Enhanced Graph Created!\n","   Nodes: 3733 | Edges: 7983\n"]},{"name":"stderr","output_type":"stream","text":["/tmp/ipykernel_17/1405026293.py:53: UserWarning: Creating a tensor from a list of numpy.ndarrays is extremely slow. Please consider converting the list to a single numpy.ndarray with numpy.array() before converting to a tensor. (Triggered internally at /pytorch/torch/csrc/utils/tensor_new.cpp:253.)\n","  edge_index = torch.tensor([all_src, all_dst], dtype=torch.long)\n"]}],"source":["import pandas as pd\n","import numpy as np\n","import torch\n","from torch_geometric.data import Data\n","\n","def build_unified_graph():\n","    print(\"üèóÔ∏è Building Enhanced Unified Graph Object...\")\n","    \n","    # 1. Load Files\n","    static_1d = pd.read_csv('/kaggle/input/urbanfloodbench/1d_nodes_static.csv')\n","    static_2d = pd.read_csv('/kaggle/input/urbanfloodbench/2d_nodes_static.csv')\n","    edges_1d_df = pd.read_csv('/kaggle/input/urbanfloodbench/1d_edge_index.csv')\n","    edges_2d_df = pd.read_csv('/kaggle/input/urbanfloodbench/2d_edge_index.csv')\n","    conn_df = pd.read_csv('/kaggle/input/urbanfloodbench/1d2d_connections.csv')\n","    \n","    num_1d_nodes = len(static_1d)\n","    num_2d_nodes = len(static_2d)\n","\n","    # 2. Node Features (X)\n","    feat_1d = static_1d[['position_x', 'position_y', 'invert_elevation', 'base_area']].values\n","    feat_2d = static_2d[['position_x', 'position_y', 'elevation', 'area']].values\n","    \n","    combined_feats = np.vstack([feat_1d, feat_2d])\n","    mean = combined_feats.mean(axis=0)\n","    std = combined_feats.std(axis=0) + 1e-6\n","    x_norm = (combined_feats - mean) / std\n","    \n","    x = torch.tensor(x_norm, dtype=torch.float)\n","    type_mask = torch.cat([torch.zeros(num_1d_nodes), torch.ones(num_2d_nodes)]).reshape(-1, 1)\n","    x = torch.cat([x, type_mask], dim=1)\n","\n","    # 3. Edge Indices\n","    # 1D\n","    src_1d = edges_1d_df['from_node'].values\n","    dst_1d = edges_1d_df['to_node'].values\n","    \n","    # 2D (Shifted)\n","    src_2d = edges_2d_df['from_node'].values + num_1d_nodes\n","    dst_2d = edges_2d_df['to_node'].values + num_1d_nodes\n","    \n","    # Coupled (Shifted)\n","    conn_df.columns = [c.strip() for c in conn_df.columns]\n","    col_1d = next((c for c in conn_df.columns if '1d' in c.lower()), '1d_node_idx')\n","    col_2d = next((c for c in conn_df.columns if '2d' in c.lower()), '2d_node_idx')\n","    \n","    src_c1 = conn_df[col_2d].values + num_1d_nodes \n","    dst_c1 = conn_df[col_1d].values\n","    src_c2 = conn_df[col_1d].values\n","    dst_c2 = conn_df[col_2d].values + num_1d_nodes\n","\n","    all_src = np.concatenate([src_1d, src_2d, src_c1, src_c2])\n","    all_dst = np.concatenate([dst_1d, dst_2d, dst_c1, dst_c2])\n","    edge_index = torch.tensor([all_src, all_dst], dtype=torch.long)\n","\n","    # 4. Edge Weights (The \"Enhanced\" Part)\n","    if 'length' in edges_1d_df.columns:\n","        # Inverse length: closer nodes have stronger influence\n","        weights_1d = 1.0 / (edges_1d_df['length'].values + 1e-6) \n","    else:\n","        weights_1d = np.ones(len(edges_1d_df))\n","\n","    weights_2d = np.ones(len(src_2d)) \n","    weights_coupled = np.ones(len(src_c1) + len(src_c2))\n","    \n","    edge_weight = torch.tensor(np.concatenate([weights_1d, weights_2d, weights_coupled]), dtype=torch.float)\n","\n","    # 5. Create Object\n","    data = Data(x=x, edge_index=edge_index, edge_attr=edge_weight)\n","    data.num_1d = num_1d_nodes\n","    data.num_2d = num_2d_nodes\n","    \n","    print(f\"‚úÖ Enhanced Graph Created!\")\n","    print(f\"   Nodes: {num_1d_nodes + num_2d_nodes} | Edges: {edge_index.shape[1]}\")\n","    \n","    return data, mean, std\n","\n","# Execute\n","graph_data, feat_mean, feat_std = build_unified_graph()"]},{"cell_type":"code","execution_count":8,"id":"ca2046a5","metadata":{"execution":{"iopub.execute_input":"2026-02-08T17:28:21.838027Z","iopub.status.busy":"2026-02-08T17:28:21.837537Z","iopub.status.idle":"2026-02-08T17:28:22.400673Z","shell.execute_reply":"2026-02-08T17:28:22.399143Z"},"papermill":{"duration":0.574865,"end_time":"2026-02-08T17:28:22.403203","exception":false,"start_time":"2026-02-08T17:28:21.828338","status":"completed"},"tags":[]},"outputs":[{"name":"stdout","output_type":"stream","text":["‚è≥ Processing Dynamic Signals...\n","‚úÖ Dynamic Tensor Created!\n","   Shape: (94, 3733, 2) (Timesteps, Nodes, Features)\n","‚úÖ Data Loader Ready! Batches: 3\n","   Sample X: torch.Size([32, 12, 3733, 2]) (Batch, In_Time, Nodes, Feats)\n","   Sample Y: torch.Size([32, 12, 3733]) (Batch, Out_Time, Nodes)\n"]}],"source":["import pandas as pd\n","import numpy as np\n","import torch\n","from torch.utils.data import Dataset, DataLoader\n","\n","# ==========================================\n","# 1. TEMPORAL DATA PROCESSOR\n","# ==========================================\n","def process_dynamic_data(graph_data):\n","    print(\"‚è≥ Processing Dynamic Signals...\")\n","    \n","    # Load raw dynamic files\n","    # Note: We use TRAINING data here to build the training set\n","    d1 = pd.read_csv('/kaggle/input/urbanfloodbench/1d_nodes_dynamic_all.csv')\n","    d2 = pd.read_csv('/kaggle/input/urbanfloodbench/2d_nodes_dynamic_all.csv')\n","    \n","    # --- A. Pivot to Matrix Form [Timestep x Node] ---\n","    # We need to guarantee the order matches the Graph Node IDs\n","    # 1D Nodes: 0 to num_1d-1\n","    # 2D Nodes: num_1d to num_1d+num_2d-1\n","    \n","    # 1. Pivot Water Levels\n","    # We use 'sum' aggregation just in case of duplicates, though there shouldn't be any\n","    w1 = d1.pivot_table(index='timestep', columns='node_idx', values='water_level', aggfunc='sum')\n","    w2 = d2.pivot_table(index='timestep', columns='node_idx', values='water_level', aggfunc='sum')\n","    \n","    # 2. Pivot Forcing (Inlet Flow for 1D, Rainfall for 2D)\n","    # Note: 2D usually has 'rainfall', 1D has 'inlet_flow'. \n","    # We will combine them into a generic \"Forcing\" feature.\n","    f1 = d1.pivot_table(index='timestep', columns='node_idx', values='inlet_flow', aggfunc='sum').fillna(0)\n","    \n","    # For 2D, if 'rainfall' column exists use it, else 0 (some datasets split rainfall separately)\n","    if 'rainfall' in d2.columns:\n","        f2 = d2.pivot_table(index='timestep', columns='node_idx', values='rainfall', aggfunc='sum').fillna(0)\n","    else:\n","        f2 = pd.DataFrame(0, index=w2.index, columns=w2.columns)\n","\n","    # --- B. Align & Concatenate ---\n","    # Ensure all timesteps are present and sorted\n","    common_index = w1.index.intersection(w2.index).sort_values()\n","    w1, w2 = w1.loc[common_index], w2.loc[common_index]\n","    f1, f2 = f1.loc[common_index], f2.loc[common_index]\n","    \n","    # Stack 1D and 2D horizontally to match Graph Node Order\n","    # Water Matrix: [Time, Total_Nodes]\n","    water_matrix = np.hstack([w1.values, w2.values])\n","    \n","    # Forcing Matrix: [Time, Total_Nodes]\n","    forcing_matrix = np.hstack([f1.values, f2.values])\n","    \n","    # --- C. Create Feature Tensor ---\n","    # Shape: [Time, Nodes, Features] -> Features = (Water_Level, Forcing)\n","    # We stack them along the last dimension\n","    # Feature 0: Water Level (Target)\n","    # Feature 1: Forcing (Input only)\n","    dynamic_tensor = np.stack([water_matrix, forcing_matrix], axis=-1)\n","    \n","    # Handle NaNs (Interpolate or Fill 0)\n","    dynamic_tensor = np.nan_to_num(dynamic_tensor)\n","    \n","    print(f\"‚úÖ Dynamic Tensor Created!\")\n","    print(f\"   Shape: {dynamic_tensor.shape} (Timesteps, Nodes, Features)\")\n","    \n","    return torch.FloatTensor(dynamic_tensor)\n","\n","# Execute\n","full_history = process_dynamic_data(graph_data)\n","\n","# ==========================================\n","# 2. SLIDING WINDOW DATASET\n","# ==========================================\n","class FloodDataset(Dataset):\n","    def __init__(self, data_tensor, input_window=12, output_window=12):\n","        \"\"\"\n","        data_tensor: [Time, Nodes, Feats]\n","        \"\"\"\n","        self.data = data_tensor\n","        self.input_window = input_window\n","        self.output_window = output_window\n","        \n","    def __len__(self):\n","        # We need enough history for input AND enough future for output\n","        return len(self.data) - self.input_window - self.output_window\n","    \n","    def __getitem__(self, idx):\n","        # Window: [t : t+In]\n","        # Target: [t+In : t+In+Out]\n","        \n","        # X: Use both features (Water + Forcing)\n","        x = self.data[idx : idx+self.input_window, :, :] \n","        \n","        # Y: Predict only Water Level (Feature 0)\n","        # We generally predict the CHANGE or the absolute value. Let's predict Absolute.\n","        y = self.data[idx+self.input_window : idx+self.input_window+self.output_window, :, 0]\n","        \n","        return x, y\n","\n","# Instantiate\n","train_dataset = FloodDataset(full_history, input_window=12, output_window=12)\n","train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)\n","\n","print(f\"‚úÖ Data Loader Ready! Batches: {len(train_loader)}\")\n","# Check shape of one batch\n","sample_x, sample_y = next(iter(train_loader))\n","print(f\"   Sample X: {sample_x.shape} (Batch, In_Time, Nodes, Feats)\")\n","print(f\"   Sample Y: {sample_y.shape} (Batch, Out_Time, Nodes)\")"]},{"cell_type":"code","execution_count":9,"id":"2ea20f6a","metadata":{"execution":{"iopub.execute_input":"2026-02-08T17:28:22.419371Z","iopub.status.busy":"2026-02-08T17:28:22.418936Z","iopub.status.idle":"2026-02-08T17:28:22.48896Z","shell.execute_reply":"2026-02-08T17:28:22.487607Z"},"papermill":{"duration":0.081165,"end_time":"2026-02-08T17:28:22.491497","exception":false,"start_time":"2026-02-08T17:28:22.410332","status":"completed"},"tags":[]},"outputs":[{"name":"stdout","output_type":"stream","text":["‚úÖ Corrected Model Defined!\n"]}],"source":["import torch\n","import torch.nn as nn\n","import torch.nn.functional as F\n","from torch_geometric.nn import GCNConv\n","\n","class FloodSTGNN(nn.Module):\n","    def __init__(self, num_nodes, in_channels=2, out_channels=12, hidden_dim=128):\n","        super(FloodSTGNN, self).__init__()\n","        \n","        self.num_nodes = num_nodes\n","        \n","        # --- 1. FEATURE EMBEDDING (The Missing Link) ---\n","        self.feature_embed = nn.Linear(in_channels, hidden_dim)\n","\n","        # --- 2. TEMPORAL BLOCK (LSTM) ---\n","        self.lstm = nn.LSTM(input_size=hidden_dim, hidden_size=hidden_dim, \n","                            num_layers=2, batch_first=True,dropout=0.2)\n","        \n","        # --- 3. SPATIAL BLOCK (Graph Convolution) ---\n","        self.gcn1 = GCNConv(hidden_dim, hidden_dim)\n","        self.gcn2 = GCNConv(hidden_dim, hidden_dim)\n","        self.gcn3 = GCNConv(hidden_dim, hidden_dim)\n","        \n","        # --- 4. OUTPUT HEAD ---\n","        self.fc = nn.Linear(hidden_dim, out_channels)\n","\n","    def forward(self, x, edge_index, edge_weight=None):\n","        \"\"\"\n","        x: [Batch, Time, Nodes, Features]\n","        \"\"\"\n","        B, T, N, F_in = x.shape\n","        \n","        # 1. Reshape for LSTM: [Batch*Nodes, Time, Features]\n","        # We treat every node as an independent sequence initially\n","        x_flat = x.permute(0, 2, 1, 3).reshape(B*N, T, F_in)\n","        \n","        # 2. Apply Embedding (Fixes the dimension mismatch)\n","        # Shape: [B*N, T, 2] -> [B*N, T, 64]\n","        x_flat = x.permute(0,2,1,3).reshape(B*N, T, F_in)\n","        x_embedded = F.relu(self.feature_embed(x_flat))\n","        x_embedded = F.relu(x_embedded) # Optional activation\n","        \n","        # 3. Run LSTM\n","        lstm_out, _ = self.lstm(x_embedded)\n","        \n","        # Take the state at the last time step\n","        last_hidden = lstm_out[:, -1, :] \n","        \n","        # 4. Reshape for GCN: [Batch, Nodes, Hidden]\n","        gcn_in = last_hidden.view(B, N, -1)\n","        \n","        # 5. Run GCN (Spatial Mixing)\n","        # We loop over the batch because GCN expects [Nodes, Feats]\n","        gcn_outs = []\n","        for b in range(B):\n","            h = F.relu(self.gcn1(gcn_in[b], edge_index, edge_weight))\n","            h = F.relu(self.gcn2(h, edge_index, edge_weight))\n","            h = F.relu(self.gcn3(h, edge_index, edge_weight))\n","            gcn_outs.append(h)\n","            \n","        # Stack back: [Batch, Nodes, Hidden]\n","        gcn_final = torch.stack(gcn_outs)\n","        \n","        # 6. Final Prediction\n","        # Shape: [Batch, Nodes, Out_Steps]\n","        out = self.fc(gcn_final)\n","        \n","        return out\n","\n","# Re-instantiate the model on GPU\n","device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n","model = FloodSTGNN(num_nodes=3733, hidden_dim=128).to(device)\n","\n","print(\"‚úÖ Corrected Model Defined!\")"]},{"cell_type":"code","execution_count":10,"id":"ee3f5c44","metadata":{"execution":{"iopub.execute_input":"2026-02-08T17:28:22.506263Z","iopub.status.busy":"2026-02-08T17:28:22.505919Z","iopub.status.idle":"2026-02-08T21:17:15.058726Z","shell.execute_reply":"2026-02-08T21:17:15.05705Z"},"papermill":{"duration":13732.572046,"end_time":"2026-02-08T21:17:15.069993","exception":false,"start_time":"2026-02-08T17:28:22.497947","status":"completed"},"tags":[]},"outputs":[{"name":"stdout","output_type":"stream","text":["üöÄ Training Deep ST-GNN with Spatial Weights...\n","Epoch 1/50 | Loss: 20.8112\n","Epoch 2/50 | Loss: 20.8025\n","Epoch 3/50 | Loss: 20.7747\n","Epoch 4/50 | Loss: 20.7252\n","Epoch 5/50 | Loss: 20.6103\n","Epoch 6/50 | Loss: 20.4301\n","Epoch 7/50 | Loss: 20.1431\n","Epoch 8/50 | Loss: 19.6838\n","Epoch 9/50 | Loss: 18.9826\n","Epoch 10/50 | Loss: 17.9558\n","Epoch 11/50 | Loss: 16.4940\n","Epoch 12/50 | Loss: 14.4587\n","Epoch 13/50 | Loss: 11.7114\n","Epoch 14/50 | Loss: 8.2088\n","Epoch 15/50 | Loss: 4.9392\n","Epoch 16/50 | Loss: 5.4622\n","Epoch 17/50 | Loss: 6.0104\n","Epoch 18/50 | Loss: 4.5736\n","Epoch 19/50 | Loss: 3.9183\n","Epoch 20/50 | Loss: 4.4070\n","Epoch 21/50 | Loss: 4.4116\n","Epoch 22/50 | Loss: 4.0012\n","Epoch 23/50 | Loss: 3.9324\n","Epoch 24/50 | Loss: 4.0662\n","Epoch 25/50 | Loss: 3.9265\n","Epoch 26/50 | Loss: 3.8261\n","Epoch 27/50 | Loss: 3.8834\n","Epoch 28/50 | Loss: 3.8700\n","Epoch 29/50 | Loss: 3.8220\n","Epoch 30/50 | Loss: 3.8379\n","Epoch 31/50 | Loss: 3.8393\n","Epoch 32/50 | Loss: 3.8153\n","Epoch 33/50 | Loss: 3.8179\n","Epoch 34/50 | Loss: 3.8205\n","Epoch 35/50 | Loss: 3.8120\n","Epoch 36/50 | Loss: 3.8136\n","Epoch 37/50 | Loss: 3.8148\n","Epoch 38/50 | Loss: 3.8106\n","Epoch 39/50 | Loss: 3.8117\n","Epoch 40/50 | Loss: 3.8109\n","Epoch 41/50 | Loss: 3.8097\n","Epoch 42/50 | Loss: 3.8111\n","Epoch 43/50 | Loss: 3.8103\n","Epoch 44/50 | Loss: 3.8096\n","Epoch 45/50 | Loss: 3.8092\n","Epoch 46/50 | Loss: 3.8093\n","Epoch 47/50 | Loss: 3.8094\n","Epoch 48/50 | Loss: 3.8090\n","Epoch 49/50 | Loss: 3.8090\n","Epoch 50/50 | Loss: 3.8085\n"]}],"source":["# Initialize\n","device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n","model = FloodSTGNN(num_nodes=3733).to(device)\n","optimizer = torch.optim.Adam(model.parameters(), lr=0.001)\n","criterion = StandardizedRMSELoss(16.80, 14.36)\n","\n","# ==========================================\n","# 2. WEIGHT-AWARE TRAINING LOOP\n","# ==========================================\n","print(\"üöÄ Training Deep ST-GNN with Spatial Weights...\")\n","\n","# Get components from graph_data\n","edge_index = graph_data.edge_index.to(device)\n","edge_weight = graph_data.edge_attr.to(device) # Our 1/L weights\n","node_type_mask = graph_data.x[:, -1].long().to(device)\n","\n","for epoch in range(50):\n","    model.train()\n","    total_loss = 0\n","    for x_batch, y_batch in train_loader:\n","        x_batch, y_batch = x_batch.to(device), y_batch.to(device)\n","        optimizer.zero_grad()\n","        \n","        # Pass edge_weight to the model!\n","        out = model(x_batch, edge_index, edge_weight).permute(0, 2, 1)\n","        \n","        loss = criterion(out, y_batch, node_type_mask)\n","        loss.backward()\n","        optimizer.step()\n","        total_loss += loss.item()\n","    \n","    print(f\"Epoch {epoch+1}/50 | Loss: {total_loss/len(train_loader):.4f}\")"]},{"cell_type":"code","execution_count":11,"id":"3c0d186a","metadata":{"execution":{"iopub.execute_input":"2026-02-08T21:17:15.089621Z","iopub.status.busy":"2026-02-08T21:17:15.088689Z","iopub.status.idle":"2026-02-08T21:30:23.714945Z","shell.execute_reply":"2026-02-08T21:30:23.713547Z"},"papermill":{"duration":788.639842,"end_time":"2026-02-08T21:30:23.718001","exception":false,"start_time":"2026-02-08T21:17:15.078159","status":"completed"},"tags":[]},"outputs":[{"name":"stdout","output_type":"stream","text":["‚è≥ Loading Test Data...\n","   Processing Forcing Features...\n","‚úÖ Inference Environment Ready. Tensor Shape: torch.Size([445, 3733, 2])\n","üöÄ Starting Deep Prediction Loop...\n","   ... Simulated Step 0/445\n","   ... Simulated Step 50/445\n","   ... Simulated Step 100/445\n","   ... Simulated Step 150/445\n","   ... Simulated Step 200/445\n","   ... Simulated Step 250/445\n","   ... Simulated Step 300/445\n","   ... Simulated Step 350/445\n","   ... Simulated Step 400/445\n","üíæ Saving Results...\n"]},{"name":"stderr","output_type":"stream","text":["/tmp/ipykernel_17/2732600312.py:110: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`\n","  ).fillna(0)\n"]},{"name":"stdout","output_type":"stream","text":["‚úÖ 'submission_gnn.csv' generated!\n"]}],"source":["import pandas as pd\n","import numpy as np\n","import torch\n","\n","# ==========================================\n","# 1. LOAD & PREPARE TEST DATA\n","# ==========================================\n","print(\"‚è≥ Loading Test Data...\")\n","# FIX: Ensure paths match your dataset name (urbanfloodbench)\n","t1 = pd.read_csv('/kaggle/input/urbanfloodbench/test_1d_nodes_dynamic_all.csv')\n","t2 = pd.read_csv('/kaggle/input/urbanfloodbench/test_2d_nodes_dynamic_all.csv')\n","\n","# --- A. Pivot Forcing Data ---\n","print(\"   Processing Forcing Features...\")\n","f1 = t1.pivot_table(index='timestep', columns='node_idx', values='inlet_flow').fillna(0)\n","if 'rainfall' in t2.columns:\n","    f2 = t2.pivot_table(index='timestep', columns='node_idx', values='rainfall').fillna(0)\n","else:\n","    f2 = pd.DataFrame(0, index=f1.index, columns=range(len(t2['node_idx'].unique())))\n","\n","# --- B. Fix Timelines ---\n","max_t = max(f1.index.max(), f2.index.max()) if not f2.empty else f1.index.max()\n","full_timeline = range(int(max_t) + 1)\n","f1 = f1.reindex(full_timeline, fill_value=0)\n","f2 = f2.reindex(full_timeline, fill_value=0)\n","\n","# --- C. Align Columns ---\n","# Use the counts directly from the graph object we built earlier\n","num_1d = graph_data.num_1d\n","num_2d = graph_data.num_2d\n","\n","f1 = f1.reindex(columns=range(num_1d), fill_value=0)\n","f2 = f2.reindex(columns=range(num_2d), fill_value=0)\n","\n","forcing_matrix = np.hstack([f1.values, f2.values]) \n","num_timesteps, num_nodes = forcing_matrix.shape\n","\n","# --- D. Initialize State ---\n","water_matrix = np.zeros((num_timesteps, num_nodes))\n","test_tensor = np.stack([water_matrix, forcing_matrix], axis=-1)\n","test_tensor = torch.FloatTensor(test_tensor).to(device)\n","\n","print(f\"‚úÖ Inference Environment Ready. Tensor Shape: {test_tensor.shape}\")\n","\n","# ==========================================\n","# 2. RUN AUTOREGRESSIVE LOOP (Deep Model)\n","# ==========================================\n","model.eval()\n","WINDOW_SIZE = 12\n","\n","# FIX: Get Edge Weights from the Graph Object for the Deep Model\n","edge_index = graph_data.edge_index.to(device)\n","edge_weight = graph_data.edge_attr.to(device) # <--- CRITICAL ADDITION\n","\n","print(\"üöÄ Starting Deep Prediction Loop...\")\n","preds_list = []\n","\n","with torch.no_grad():\n","    for t in range(num_timesteps):\n","        # 1. Construct Input Window\n","        if t < WINDOW_SIZE:\n","            padding = test_tensor[0:1].repeat(WINDOW_SIZE - (t + 1), 1, 1)\n","            history = test_tensor[0 : t + 1]\n","            input_window = torch.cat([padding, history], dim=0)\n","        else:\n","            input_window = test_tensor[t - WINDOW_SIZE + 1 : t + 1]\n","        \n","        input_window = input_window.unsqueeze(0) \n","        \n","        # 2. Predict (PASS EDGE_WEIGHT HERE!)\n","        preds = model(input_window, edge_index, edge_weight) \n","        \n","        # 3. Update State\n","        next_val = preds[0, :, 0] \n","        \n","        if t + 1 < num_timesteps:\n","            test_tensor[t + 1, :, 0] = next_val\n","            \n","        preds_list.append(next_val.cpu().numpy())\n","\n","        if t % 50 == 0: print(f\"   ... Simulated Step {t}/{num_timesteps}\")\n","\n","# ==========================================\n","# 3. EXPORT SUBMISSION\n","# ==========================================\n","print(\"üíæ Saving Results...\")\n","all_preds = np.stack(preds_list)\n","\n","# Map to DataFrame\n","df_preds = pd.DataFrame(all_preds, columns=range(num_nodes))\n","df_preds['timestep'] = range(num_timesteps)\n","df_long = df_preds.melt(id_vars='timestep', var_name='graph_node_idx', value_name='water_level')\n","\n","# Vectorized mapping\n","df_long['node_type'] = np.where(df_long['graph_node_idx'] < num_1d, 1, 0)\n","df_long['node_id'] = np.where(df_long['graph_node_idx'] < num_1d, df_long['graph_node_idx'], df_long['graph_node_idx'] - num_1d)\n","\n","# Load Sample Sub\n","sample_sub = pd.read_csv('/kaggle/input/urbanfloodbench/sample_submission.csv')\n","merge_keys = ['node_type', 'node_id', 'timestep']\n","\n","if 'timestep' not in sample_sub.columns:\n","    sample_sub['timestep'] = sample_sub.groupby(['model_id', 'event_id', 'node_type', 'node_id']).cumcount()\n","\n","# Merge\n","final_df = sample_sub.drop(columns=['water_level']).merge(\n","    df_long[['node_type', 'node_id', 'timestep', 'water_level']], \n","    on=merge_keys, \n","    how='left'\n",").fillna(0)\n","\n","# Save the GNN specific file for Ensemble use\n","final_df.to_csv('submission_gnn.csv', index=False)\n","print(\"‚úÖ 'submission_gnn.csv' generated!\")\n","\n","# Save a direct submission copy just in case\n","sample_cols = pd.read_csv('/kaggle/input/urbanfloodbench/sample_submission.csv').columns.tolist()\n","final_df[sample_cols].to_csv('submission.csv', index=False)"]},{"cell_type":"code","execution_count":12,"id":"fd4e6750","metadata":{"execution":{"iopub.execute_input":"2026-02-08T21:30:23.738579Z","iopub.status.busy":"2026-02-08T21:30:23.737756Z","iopub.status.idle":"2026-02-08T21:32:38.475317Z","shell.execute_reply":"2026-02-08T21:32:38.473599Z"},"papermill":{"duration":134.75971,"end_time":"2026-02-08T21:32:38.487164","exception":false,"start_time":"2026-02-08T21:30:23.727454","status":"completed"},"tags":[]},"outputs":[{"name":"stdout","output_type":"stream","text":["‚úÖ 'submission.csv' generated with columns: ['row_id', 'model_id', 'event_id', 'node_type', 'node_id', 'water_level']\n","Sample row:\n","   row_id  model_id  event_id  node_type  node_id  water_level\n","0       0         1         5          1        0   311.858124\n","üöÄ Column count matches sample_submission exactly!\n"]}],"source":["import pandas as pd\n","\n","# 1. Load the sample submission to use as a strict template\n","sample_sub_template = pd.read_csv('/kaggle/input/urbanfloodbench/sample_submission.csv')\n","\n","# 2. Identify the required columns (e.g., model_id, event_id, node_type, node_id, water_level)\n","required_columns = sample_sub_template.columns.tolist()\n","\n","# 3. Filter your final_df to include ONLY those columns\n","# This effectively deletes 'timestep' and 'graph_node_idx'\n","final_submission = final_df[required_columns].copy()\n","\n","# 4. Final verification: Check for NaNs one last time\n","final_submission['water_level'] = final_submission['water_level'].fillna(0)\n","\n","# 5. Save the file\n","final_submission.to_csv('submission.csv', index=False)\n","\n","print(f\"‚úÖ 'submission.csv' generated with columns: {final_submission.columns.tolist()}\")\n","print(f\"Sample row:\\n{final_submission.head(1)}\")\n","\n","# Safety check: Compare column count\n","if len(final_submission.columns) == len(required_columns):\n","    print(\"üöÄ Column count matches sample_submission exactly!\")\n","else:\n","    print(\"‚ö†Ô∏è Column count mismatch. Please check the required columns list.\")"]},{"cell_type":"code","execution_count":13,"id":"ba624bfd","metadata":{"execution":{"iopub.execute_input":"2026-02-08T21:32:38.506647Z","iopub.status.busy":"2026-02-08T21:32:38.505937Z","iopub.status.idle":"2026-02-08T21:35:24.102333Z","shell.execute_reply":"2026-02-08T21:35:24.101032Z"},"papermill":{"duration":165.609428,"end_time":"2026-02-08T21:35:24.105122","exception":false,"start_time":"2026-02-08T21:32:38.495694","status":"completed"},"tags":[]},"outputs":[],"source":["# Load both\n","df_xgb = pd.read_csv('/kaggle/input/submission/submission.csv')\n","df_gnn = pd.read_csv('/kaggle/input/submission/submission_gnn.csv')\n","\n","df_xgb['water_level'] = (0.7 * df_gnn['water_level']) + (0.3 * df_xgb['water_level'])\n","\n","df_xgb.to_csv('submission_ensemble.csv', index=False)"]},{"cell_type":"code","execution_count":14,"id":"a66202be","metadata":{"execution":{"iopub.execute_input":"2026-02-08T21:35:24.125281Z","iopub.status.busy":"2026-02-08T21:35:24.124724Z","iopub.status.idle":"2026-02-08T21:35:27.126769Z","shell.execute_reply":"2026-02-08T21:35:27.125155Z"},"papermill":{"duration":3.015071,"end_time":"2026-02-08T21:35:27.129374","exception":false,"start_time":"2026-02-08T21:35:24.114303","status":"completed"},"tags":[]},"outputs":[{"name":"stdout","output_type":"stream","text":["Negative values found: 0\n"]},{"data":{"image/png":"iVBORw0KGgoAAAANSUhEUgAAAy0AAAHDCAYAAAApwfXdAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjAsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvlHJYcgAAAAlwSFlzAAAPYQAAD2EBqD+naQAAR9BJREFUeJzt3XlcF9Xi//H3R5APsiuIaC6o4J5el1wws9RcUrNyy6jQtLKwMtOSumlmpq2mpVg3Q29Zmpk397Tccs/d1HAJl1TEFsEVFM7vD3/M148sgoqM+Xo+HvPIz5kzM2fmAM37M3NmHMYYIwAAAACwqSKF3QAAAAAAyA2hBQAAAICtEVoAAAAA2BqhBQAAAICtEVoAAAAA2BqhBQAAAICtEVoAAAAA2BqhBQAAAICtEVoAAAAA2BqhBQBs5rXXXpPD4SiQdd9555268847C2Tdl3I4HHrttdesz5n79ccff1yX7YeGhqpnz57XZVvI6tL+B4CrQWgBkK2vv/5aDodDM2fOzDKvTp06cjgcWrJkSZZ55cuXV0RERL62NX78eE2aNOlKm3pFQkND1aFDh+u6zWutZ8+ecjgc1uTj46NKlSqpS5cumjFjhjIyMq7JdlatWqXXXntNx48fvybru5bs3La9e/fqySefVKVKleTp6Sk/Pz81bdpUY8aM0ZkzZwq7eQBwQ3Ev7AYAsKfbb79dkrRixQrdf//9VnlKSop++eUXubu7a+XKlbrrrruseQcPHtTBgwf14IMP5mtb48ePV1BQEN+KXwGn06lPP/1UknTmzBnt379fs2fPVpcuXXTnnXfqu+++k5+fn1V/4cKF+d7GqlWrNGzYMPXs2VMBAQF5Xu7MmTNydy/Y/83k1rb4+HgVKVI4383NnTtXXbt2ldPp1KOPPqpatWopLS1NK1as0KBBg7R9+3Z98sknhdK26+V69D+Amwd/TQBkq0yZMqpYsaJWrFjhUr569WoZY9S1a9cs8zI/ZwaewnT+/HllZGTIw8OjsJtSoNzd3fXwww+7lL3xxhsaNWqUYmJi9Pjjj2vatGnWvII+HhkZGUpLS5Onp6c8PT0LdFuX43Q6C2W7CQkJevDBB1WhQgUtXrxYpUuXtuZFR0drz549mjt3bqG0raDZqf8B/LNwexiAHN1+++3atGmTy60sK1euVM2aNdWuXTutWbPG5RaklStXyuFwqGnTppKkuLg4tWjRQsHBwXI6napRo4ZiY2NdthEaGqrt27dr2bJl1m1OF4+5OH78uPr3769y5crJ6XQqLCxMb731lst29+3bJ4fDoXfffVcffPCBKleuLKfTqR07dlz1Mfjiiy9Uv359FStWTCVKlNCDDz6ogwcPWvP79esnHx8fnT59OsuyPXr0UEhIiNLT062y+fPnq1mzZvL29pavr6/at2+v7du3X3U7LzV48GC1bt1a06dP165du6zy7Ma0fPjhh6pZs6a8vLxUvHhxNWjQQF9++aWkC+NQBg0aJEmqWLGi1Uf79u2TdGHcQr9+/TRlyhTVrFlTTqdTCxYssOZlN6bhjz/+ULdu3eTn56fAwEA999xzOnv2rDU/sz+zu2Xw4nVerm3ZjWn57bff1LVrV5UoUUJeXl5q3LhxlgCxdOlSORwOff311xoxYoTKli0rT09PtWzZUnv27MnxmGd6++23dfLkSU2cONElsGQKCwvTc889Z30+f/68hg8fbv3choaG6uWXX1ZqaqrLcpm3NC5dulQNGjRQsWLFdOutt2rp0qWSpG+//Va33nqrPD09Vb9+fW3atMll+Z49e8rHx0e//fab2rRpI29vb5UpU0avv/66jDEudd99911FREQoMDBQxYoVU/369fXNN99k2Zf89P+JEyfUv39/hYaGyul0Kjg4WHfffbc2btzoss7p06dbv3NBQUF6+OGHdejQoWz35dChQ7rvvvvk4+OjkiVLauDAgS6/bwD+ObjSAiBHt99+uz7//HOtXbvWOtFduXKlIiIiFBERoeTkZP3yyy+qXbu2Na9atWoKDAyUJMXGxqpmzZq699575e7urtmzZ+vpp59WRkaGoqOjJUkffPCBnnnmGfn4+OiVV16RJJUqVUqSdPr0aTVv3lyHDh3Sk08+qfLly2vVqlWKiYnRkSNH9MEHH7i0Ny4uTmfPntUTTzwhp9OpEiVKXNX+jxgxQq+++qq6deumPn366NixY/rwww91xx13aNOmTQoICFD37t01btw463agTKdPn9bs2bPVs2dPubm5SZI+//xzRUVFqU2bNnrrrbd0+vRpxcbGWuEwNDT0qtp7qUceeUQLFy7UokWLVKVKlWzr/Oc//9Gzzz6rLl26WOFh69atWrt2rR566CE98MAD2rVrl7766iuNHj1aQUFBkqSSJUta61i8eLG+/vpr9evXT0FBQZfdj27duik0NFQjR47UmjVrNHbsWP3999/673//m6/9y0vbLnb06FFFRETo9OnTevbZZxUYGKjJkyfr3nvv1TfffONyG6QkjRo1SkWKFNHAgQOVnJyst99+W5GRkVq7dm2u7Zo9e7YqVaqU57Fdffr00eTJk9WlSxe98MILWrt2rUaOHKmdO3dmGVO2Z88ePfTQQ3ryySf18MMP691331XHjh01YcIEvfzyy3r66aclSSNHjlS3bt2y3CKXnp6utm3bqnHjxnr77be1YMECDR06VOfPn9frr79u1RszZozuvfdeRUZGKi0tTVOnTlXXrl01Z84ctW/f3qVNee3/vn376ptvvlG/fv1Uo0YN/fnnn1qxYoV27typevXqSZImTZqkXr166bbbbtPIkSN19OhRjRkzRitXrrR+5y7elzZt2qhRo0Z699139cMPP+i9995T5cqV9dRTT+Xp2AO4gRgAyMH27duNJDN8+HBjjDHnzp0z3t7eZvLkycYYY0qVKmXGjRtnjDEmJSXFuLm5mccff9xa/vTp01nW2aZNG1OpUiWXspo1a5rmzZtnqTt8+HDj7e1tdu3a5VI+ePBg4+bmZg4cOGCMMSYhIcFIMn5+fiYpKSlP+1ahQgXTvn37HOfv27fPuLm5mREjRriUb9u2zbi7u1vlGRkZ5pZbbjGdO3d2qff1118bSWb58uXGGGNOnDhhAgICXI6PMcYkJiYaf39/l/KhQ4eavPx5joqKMt7e3jnO37Rpk5Fknn/+eausefPmLse6U6dOpmbNmrlu55133jGSTEJCQpZ5kkyRIkXM9u3bs503dOhQ63Pmft17770u9Z5++mkjyWzZssUY83/9GRcXd9l15ta2ChUqmKioKOtz//79jSTz008/WWUnTpwwFStWNKGhoSY9Pd0YY8ySJUuMJFO9enWTmppq1R0zZoyRZLZt25ZlW5mSk5ONJNOpU6cc61xs8+bNRpLp06ePS/nAgQONJLN48WKX/ZFkVq1aZZV9//33RpIpVqyY2b9/v1X+8ccfG0lmyZIlVllUVJSRZJ555hmrLCMjw7Rv3954eHiYY8eOWeWX/u6mpaWZWrVqmRYtWriU56f//f39TXR0dI7HIi0tzQQHB5tatWqZM2fOWOVz5swxksyQIUOy7Mvrr7/uso66deua+vXr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u+eee7Ru3TqtXr3aKjt16pQ++eQThYaG5mtcTm5efPFFeXt7q0+fPjp69GiW+Xv37tWYMWOsNknK8iS8999/X5KyPKnrWvjoo4+sfxtj9NFHH6lo0aJq2bKlpAu/uw6Hw+XK1r59+/J9G/fF0tPTs9xaFhwcrDJlyliPdm7QoIGCg4M1YcIEl8c9z58/Xzt37iyQYwHgxmHLRx4fOHBAcXFxOnDggMqUKSPpwu1gCxYsUFxcnN58802X+mfPntWUKVM0ePDgwmgu8I/m4eGh2267TT/99JOcTqfq16/vMj8iIkLvvfeeJNfxLK1bt5aHh4c6duyoJ598UidPntR//vMfBQcH68iRIy7rqF+/vmJjY/XGG28oLCxMwcHBatGihQYNGqRZs2apQ4cO6tmzp+rXr69Tp05p27Zt+uabb7Rv3z7rMbdXYs+ePXrjjTeylNetW1ft27fXG2+8oZiYGO3bt0/33XeffH19lZCQoJkzZ+qJJ57QwIEDrWXq1aunsLAwvfLKK0pNTXW5NUy6cCIeGxurRx55RPXq1dODDz6okiVL6sCBA5o7d66aNm3qcjKZV+fPn9cXX3wh6cLfwv3792vWrFnaunWr7rrrrsu+db1169YKCQlR06ZNVapUKe3cuVMfffSR2rdvb42FyezzV155RQ8++KCKFi2qjh07XvEYwoSEBN17771q27atVq9erS+++EIPPfSQ6tSpY9Xp06ePRo0apT59+qhBgwZavny5y/tmMuWnbYMHD9ZXX32ldu3a6dlnn1WJEiU0efJkJSQkaMaMGS6PBr4alStX1pdffqnu3burevXqevTRR1WrVi2lpaVp1apVmj59uvX+mDp16igqKkqffPKJjh8/rubNm2vdunWaPHmy7rvvPt11113XpE2ZPD09tWDBAkVFRalRo0aaP3++5s6dq5dfftkaH9K+fXu9//77atu2rR566CElJSVp3LhxCgsL09atW69ouydOnFDZsmXVpUsX1alTRz4+Pvrhhx/0888/W38/ihYtqrfeeku9evVS8+bN1aNHD+uRx6GhoXr++eev2XEAcAMqtOeWXUSSmTlzpvU58/GG3t7eLpO7u7vp1q1bluW//PJL4+7ubhITE69jq4GbR0xMjJFkIiIissz79ttvjSTj6+trzp8/7zJv1qxZpnbt2sbT09OEhoaat956y3z2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rFihZs2aqVixYipXrpyeffZZnTp1Ksf6x44d0+LFi11uC0pOTtbEiRP1/vvvq0WLFqpfv77i4uK0atWqLFczLnbpMf7uu+901113qVKlSpIuXJXo37+/+vfvr8mTJ6tFixaqUKGCateureeee07r16/Pss5nnnlGQ4cOdbkikJ0nnnhCa9as0bx583Ktdy0tXLhQO3bs0BdffKF//etfateunYYPH65x48YpLS0tx+Wef/55NW7cWBUqVFBERIQGDx6sNWvW6Ny5c5Iu/DxOnDhRa9eu1YQJE5SSkqLHHntMAwYMUEREhCTJGKOePXuqSpUqWrlypTp27Kjw8HCFh4erR48eWrFihWrXru2y3YCAAIWEhKhcuXLq0KGDOnXqpI0bN7rU6dixo2bNmqUzZ85c46PlitACAABwBYYNG6Zu3bpp69atuueeexQZGam//vpLkvTqq69qx44dmj9/vnbu3KnY2FgFBQVJks6dO6c2bdrI19dXP/30k1auXCkfHx+1bdvW5cR18eLFOnz4sJYvX673339fQ4cOVYcOHVS8eHGtXbtWffv21ZNPPqnff//dpV2DBg3SCy+8oE2bNqlJkybq2LGj/vzzz2z3Ye/evWrbtq06d+6srVu3atq0aVqxYoX69euX436vWLFCXl5eql69ulW2YcMGnTt3Tq1atbLKqlWrpvLly2v16tV5Op5Hjx7V3LlzXa4WzJgxQ+fOndOLL76Y7TIOhyNLWf/+/XX+/Hl9+OGHuW6vYsWK6tu3r2JiYpSRkZGnNl6t1atX69Zbb1WpUqWssjZt2iglJSXLVY6c/PXXX5oyZYoiIiJUtGhRq7xcuXL64IMPNGjQID388MPy8fHR8OHDrfmbN2/Wzp07NXDgQJcrZBfL7nhm2rVrlxYvXqxGjRq5lDdo0EDnz5/X2rVr89T+K0VoAQAAuMScOXPk4+PjMr355psudXr27KkePXooLCxMb775pk6ePKl169ZJunCFoG7dumrQoIFCQ0PVqlUr68rEtGnTlJGRoU8//VS33nqrqlevrri4OB04cEBLly611l+iRAmNHTtWVatW1WOPPaaqVavq9OnTevnllxUeHq6YmBh5eHhoxYoVLu3q16+fOnfurOrVqys2Nlb+/v6aOHFitvs5cuRIRUZGqn///goPD1dERITGjh2r//73vzp79my2y+zfv1+lSpVyOfFNTEyUh4eHAgICXOqWKlVKiYmJeTrmkydPlq+vr8stZbt27ZKfn59CQkKsshkzZrj0y7Zt21zW4+XlpaFDh2rkyJFKTk7OdZv//ve/lZCQoClTpuSpjVcrMTHRJbBIsj5f7ji99NJL8vb2VmBgoA4cOKDvvvsuS51evXqpVq1amj17tuLi4uR0Oq15u3btkiRVrVrVKktKSnI5luPHj3dZX48ePeTj4yNPT09VrVpVNWvWVExMjEsdLy8v+fv7a//+/Xk4AleO0AIAAHCJu+66S5s3b3aZ+vbt61Ln4ltpvL295efnp6SkJEnSU089palTp+pf//qXXnzxRa1atcqqu2XLFu3Zs0e+vr7WyWKJEiV09uxZ7d2716pXs2ZNl2BQqlQp3XrrrdZnNzc3BQYGWtvM1KRJE+vf7u7uatCggXbu3Jntfm7ZskWTJk1yOXFt06aNMjIylJCQkO0yZ86ckaenZ47H7kp99tlnioyMzLLuS7/9b9OmjTZv3qy5c+fq1KlTWQbdS1Lv3r0VGBiot956K9dtlixZUgMHDtSQIUNyvT3rYhcfq3bt2unAgQMuZZf+nFwrgwYN0qZNm7Rw4UK5ubnp0UcflTHGpc6WLVu0ceNGeXl55WlwfGBgoPXzHRAQkOUYjB49Wps3b9aWLVs0Z84c7dq1S4888kiW9RQrVsxlsH9BcC/QtQMAANyAvL29FRYWlmudi2/NkS6cXGfeZtSuXTvt379f8+bN06JFi9SyZUtFR0fr3Xff1cmTJ1W/fv1sv90vWbJkruvPbZtX4uTJk3ryySf17LPPZplXvnz5bJcJCgrS33//7VIWEhKitLQ0HT9+3OVqy9GjR12ukuTkp59+Unx8vKZNm+ZSHh4eruTkZCUmJlrr8fHxUVhYmNzdcz6NdXd314gRI9SzZ89cb3WTpAEDBmj8+PFZrjLk5OJHSq9du1YvvfSSyxUyPz+/HJcNCQmxrsZlynzC2uWOU1BQkIKCglSlShVVr15d5cqV05o1a6yQmpaWpkcffVSRkZFq3ry5+vbtqw4dOlhXVsLDwyVJ8fHxqlu3rqQLwTfz5zy74xkSEmLNr1q1qk6cOKEePXrojTfecPn9+Ouvv1x+dgsCV1oAAAAKQMmSJRUVFaUvvvhCH3zwgT755BNJUr169bR7924FBwcrLCzMZfL397/q7V488P38+fPasGGDy/iTi9WrV087duzI0o6wsDB5eHhku0zdunWVmJjoElzq16+vokWL6scff7TK4uPjdeDAAZcrPzmZOHGi6tevrzp16riUd+nSRUWLFr3sFZPsdO3aVTVr1tSwYcNyrefj46NXX31VI0aM0IkTJy673ouP0S233CJ3d3eXsuDg4ByXbdKkibZt2+ZydWzRokXy8/NTjRo18rxvmUH14ocNvP766/rrr780evRoRUVF6e6771avXr2sunXr1lW1atX07rvvXnHQdXNzkySXQfd79+7V2bNnrSBUUAgtAAAAl0hNTVViYqLL9Mcff+R5+SFDhui7777Tnj17tH37ds2ZM8cKDpGRkQoKClKnTp30008/KSEhQUuXLtWzzz6bZVD9lRg3bpxmzpypX3/9VdHR0fr777/12GOPZVv3pZde0qpVq9SvXz9t3rxZu3fv1nfffZfr1Ym6desqKChIK1eutMr8/f3Vu3dvDRgwQEuWLNGGDRvUq1cvNWnSRI0bN7bqVatWTTNnznRZX0pKiqZPn64+ffpk2Vb58uX13nvvacyYMYqKitKSJUu0b98+bdy40XrMbuaJdHZGjRqlzz77LNenoUkXniTm7+9f4C/LbN26tWrUqKFHHnlEW7Zs0ffff69///vfio6OtsafrFu3TtWqVdOhQ4ckXbia89FHH2nz5s3av3+/Fi9erB49eqhy5cpWIPz555/11ltvaeLEiVbw/fjjjxUfH6/Ro0dLunBVLi4uTvHx8WratKlmzZql3bt3a8eOHZowYYKOHTuW5VgeP35ciYmJOnz4sJYtW6bXX3/dutKT6aefflKlSpVUuXLlAj12hBYAAIBLLFiwQKVLl3aZbr/99jwv7+HhoZiYGNWuXVt33HGH3NzcNHXqVEkXBi4vX75c5cuX1wMPPKDq1aurd+/eOnv2bK63FuXVqFGjNGrUKNWpU0crVqzQrFmzrCeXXap27dpatmyZdu3apWbNmqlu3boaMmSIypQpk+P63dzc1KtXryy3t40ePVodOnRQ586ddccddygkJETffvutS534+Pgsg+OnTp0qY4x69OiR7faeeeYZLVy4UMeOHVOXLl0UHh6ue+65RwkJCVqwYIHLOJ9LtWjRQi1atLjsyxuLFi2q4cOH5/jwgWvFzc1Nc+bMkZubm5o0aaKHH35Yjz76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\n","text/plain":["<Figure size 1000x500 with 1 Axes>"]},"metadata":{},"output_type":"display_data"}],"source":["import matplotlib.pyplot as plt\n","\n","print(f\"Negative values found: {(df_xgb['water_level'] < 0).sum()}\")\n","df_xgb['water_level'] = df_xgb['water_level'].clip(lower=0)\n","\n","# 2. Compare Distributions\n","plt.figure(figsize=(10, 5))\n","plt.hist(df_gnn['water_level'], bins=50, alpha=0.5, label='GNN Only')\n","plt.hist(df_xgb['water_level'], bins=50, alpha=0.5, label='Ensemble (0.7GNN + 0.3XGB)')\n","plt.legend()\n","plt.title(\"Water Level Distribution Comparison\")\n","plt.show()"]},{"cell_type":"code","execution_count":15,"id":"b383a882","metadata":{"execution":{"iopub.execute_input":"2026-02-08T21:35:27.150532Z","iopub.status.busy":"2026-02-08T21:35:27.14993Z","iopub.status.idle":"2026-02-08T21:37:52.907854Z","shell.execute_reply":"2026-02-08T21:37:52.905859Z"},"papermill":{"duration":145.786659,"end_time":"2026-02-08T21:37:52.925682","exception":false,"start_time":"2026-02-08T21:35:27.139023","status":"completed"},"tags":[]},"outputs":[{"name":"stdout","output_type":"stream","text":["üöÄ Final submission file ready!\n"]}],"source":["# Load the original sample to check column order\n","sample_sub = pd.read_csv('/kaggle/input/urbanfloodbench/sample_submission.csv')\n","\n","# Ensure columns are in the exact same order\n","df_final = df_xgb[sample_sub.columns]\n","\n","# Save for the final time\n","df_final.to_csv('submission_final_ensemble.csv', index=False)\n","print(\"üöÄ Final submission file ready!\")"]}],"metadata":{"kaggle":{"accelerator":"none","dataSources":[{"datasetId":9434919,"sourceId":14761150,"sourceType":"datasetVersion"},{"datasetId":9441414,"sourceId":14770708,"sourceType":"datasetVersion"}],"dockerImageVersionId":31260,"isGpuEnabled":false,"isInternetEnabled":true,"language":"python","sourceType":"notebook"},"kernelspec":{"display_name":"Python 3","language":"python","name":"python3"},"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.12.12"},"papermill":{"default_parameters":{},"duration":15013.734496,"end_time":"2026-02-08T21:37:55.661708","environment_variables":{},"exception":null,"input_path":"__notebook__.ipynb","output_path":"__notebook__.ipynb","parameters":{},"start_time":"2026-02-08T17:27:41.927212","version":"2.6.0"}},"nbformat":4,"nbformat_minor":5}